<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/style.css">
    <title>Aurora</title>
</head>

<body>
    <main class="container-sm">
        <article>
            <h1>Aurora</h1>
            <p>Ozone sanitization system for the food industry.</p>
            <h2>Scope</h2>
            <ul>
                <li>Gaseous ozone</li>
                <li>Environments sanitization</li>
                <li>Volume max 1000m3</li>
            </ul>
            <h2>DONE</h2>
            <ul>
                <li>Ozone output selection (1g/h - 10g/h)</li>
                <li>Oxygen concentrator of ozone production</li>
                <li>Calendar for ozone production (days)</li>
                <li>Ozone sensor (read-only)</li>
                <li>Touch screen 7" (HMI)</li>
            </ul>
            <h2>TO DO</h2>
            <ul>
                <li>Include modbus (internal components communication)</li>
                <li>Include a second ozone generator to produce ozone without pauses</li>
                <li>Include oxygen sensor to monitor the state/performance of the oxygen concentrator</li>
                <li>Replace ozone generators with adjustable ones (variable output selected from software)</li>
                <li>Include web server (read-only data)</li>
            </ul>

            <!-- DOING NOW -->

            <h2>DOING NOW (MODBUS)</h2>

            <h3>INTRO</h3>

            <p>The modbus query is formatted as a bytestream of 8 bytes.</p>

            <h3>USAGE</h3>

            <p>Master can send the following queries (bytestreams).</p>

            <p><b>Read Ozone Sensor (ppb)</b></p>
            <pre><code>
[0x16][0x04][0x00][0x12][0x00][0x01][0x00][0x00]
            </code></pre>
            <p>NOTE: Update the command above with correct crc. Use function <code
                    style="font-weight: bold; color: #c026d3;">modbus_crc16</code> for
                automatic crc calculation and update.</p>

            <h3>IMPLEMENTATION</h3>
            <p><b>QUERY FORMAT</b></p>
            <pre><code>
[id][cmd][st_reg_hb][st_reg_lb][fl_reg_hb][fl_reg_lb][crc_hb][crc_lb]
            </code></pre>
            <p><b>QUERY LEGEND</b></p>
            <ul>
                <li><b>id</b>: ID device</li>
                <li><b>cmd</b>: Command to send</li>
                <li><b>st_reg_hb</b>: Start register address (high-byte)</li>
                <li><b>st_reg_lb</b>: Start register address (low-byte)</li>
                <li><b>fl_reg_hb</b>: Number of following registers to read (high-byte)</li>
                <li><b>fl_reg_lb</b>: Number of following registers to read (low-byte)</li>
                <li><b>crc_hb</b>: CRC16 code (high-byte)</li>
                <li><b>crc_lb</b>: CRC16 code (low-byte)</li>
            </ul>

            <p><b>QUERIES TO SEND</b></p>
            <p>Define and init queries with the following line of code (where you replace "buf" with a good variable
                name for the query).</p>
            <pre><code>
uint8_t query_pressure_analog_in[8] = {0x16, 0x04, 0x00, 0x12, 0x00, 0x01, 0x00, 0x00};
            </code></pre>
            <p>WARNING: The last 2 bytes are the CRC16, so they must be calculated and updated in the buffer before
                sending it as query. To calculate the CRC16, use the function provided somewhere below in this page.</p>

            <p>Read Ozone Sensor</p>
            <pre><code>
[0x16][0x04][0x00][0x01][0x00][0x01][0x00][0x00]
            </code></pre>

            <p>Read Oxygen Sensor</p>
            <pre><code>
[0x16][0x04][0x00][0x02][0x00][0x01][0x00][0x00]
            </code></pre>

            <!-- // buffer send format (8 bytes total)
            // buffer[0] = device id
            // buffer[1] = comand - 1: read coil status (digital out)
            // - 2: read input status (digital in)
            // - 3: read holding registers (analog out)
            // - 4: read input registers (analog in)
            // - ?: force single coil
            // - ?: preset single register
            // buffer[2:3] = start register address (2 bytes)
            // buffer[4:5] = number of consecutive data bytes (2 bytes)
            // buffer[6:7] = CRC (2 bytes) -->

            <p style="font-weight: bold;">DEF: NETWORK SERIAL</p>
            <p>Global code, place it at the top of main.</p>
            <pre><code>
HardwareSerial serial_modbus(1);
            </code></pre>

            <p style="font-weight: bold;">INIT: NETWORK SERIAL</p>
            <p>Setup code, place it in the SETUP() function.</p>
            <pre><code>
serial_modbus.begin(9600, SERIAL_8N1, 17, 4);
            </code></pre>

            <p style="font-weight: bold;">DEF/INIT:: NETWORK SETTINGS</p>
            <p>Use the following settings for all devices in the modbus network.</p>
            <p>NOTE: Code not yet implemented.</p>
            <pre><code>
uint32_t baud_rate = 9600;
uint8_t n_data_bits = 8;
uint8_t n_stop_bits = 1;
uint8_t parity = 0;
            </code></pre>

            <p style="font-weight: bold;">DEF/INIT: MODBUS STRUCT</p>
            <p>This struct store the modbus data. Include it at the top of the main program file. The functions below
                need this struct to work.</p>
            <pre><code>
typedef struct modbus_t {
    uint8_t sender_buff[8] = {0};
    uint8_t sender_buff_index = 0;
    uint32_t sender_timer = 0;
    
    uint8_t receiver_buff[8] = {0};
    uint8_t receiver_buff_index = 0;
    uint32_t receiver_timer = 0;
    
    uint8_t bytestream_receiving = 0;
    uint8_t bytestream_received = 0;
} modbus_t;
modbus_t modbus = {};
            </code></pre>

            <p style="font-weight: bold;">FUN: Write ByteStream (Send Query/Response)</p>
            <p>Write bytestream of chosen buffer to modbus.</p>
            <pre><code>
void modbus_write(uint8_t *buf, int len) 
{
  for(int pos = 0; pos < len; pos++)
  {
    serial_modbus.write(buf[pos]);
  }
}
            </code></pre>

            <p style="font-weight: bold;">FUN: Read ByteStream (Receive Query/Response)</p>
            <p>Read incoming bytestream, save complete stream in <code
                    style="font-weight: bold; color: #c026d3;">modbus.receiver_buff</code> and notify complete
                bytestream with <code style="font-weight: bold; color: #c026d3;">modbus.bytestream_received</code>.</p>
            <pre><code>
void modbus_read() 
{
    if (serial_modbus.available() > 0) 
    {
        uint8_t c = serial_modbus.read();
        modbus.receiver_buff[modbus.receiver_buff_index] = c;
        modbus.receiver_buff_index++;
        modbus.bytestream_receiving = 1;
        modbus.receiver_timer = millis();
    }

    if (modbus.bytestream_receiving) 
    {
        if (millis() - modbus.receiver_timer > 40) 
        {
            modbus.receiver_buff_index = 0;
            modbus.bytestream_receiving = 0;
            modbus.bytestream_received = 1;
        }
    }
}
            </code></pre>

            <p style="font-weight: bold;">FUN: Calculate CRC16</p>
            <p>Calculate and return the Modbus CRC16 value.</p>
            <pre><code>
uint16_t modbus_crc16(uint8_t *buf, int len)
{
    uint16_t crc = 0xFFFF;
    for (int pos = 0; pos < len; pos++) 
    {
        crc ^= (uint16_t)buf[pos];
        for (int i = 8; i != 0; i--) 
        {
            if ((crc & 0x0001) != 0) 
            {
                crc >>= 1;
                crc ^= 0xA001;
            }
            else
            {
                crc >>= 1;
            }
        }
    }
    return crc;  
}
            </code></pre>


            <p style="font-weight: bold;">FUN: Print ByteStream (Debug)</p>
            <p>Print the bytestream buffer in the main serial interface. This function is used for debug purpose only,
                to check if the bytestreams are sent/received correctly.</p>
            <pre><code>
void modbus_print(uint8_t *buf, int len) 
{
  for(int i = 0; i < len; i++)
  {
    Serial.print("0x");
    Serial.print(buf[i], HEX);
    Serial.print(" ");
  }
  Serial.println();
}
            </code></pre>
        </article>
    </main>
</body>

</html>